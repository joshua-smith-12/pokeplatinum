#!/usr/bin/env python3
import argparse
import json
import pathlib
import subprocess
import struct

RESDAT_TYPES = ["TILES", "PALETTE", "CELLS", "ANIM", "MULTI_CELLS", "MULTI_ANIM"]

argparser = argparse.ArgumentParser(
    prog='make_resdat.py',
    description='Packs resdat binaries'
)
argparser.add_argument('-s', '--source-file',
                       required=True,
                       help='Path to the source file')
argparser.add_argument('-o', '--output-file',
                       required=True,
                       help='Path to the output file (where the resdat binary will be output)')
args = argparser.parse_args()

source_file = pathlib.Path(args.source_file)
output_file = pathlib.Path(args.output_file)

with open(source_file) as infile:
    data = json.loads(infile.read())

type_idx = RESDAT_TYPES.index(data['type'])
# for palette resdats, output a header which C sources can consume
output_header = data['type'] == "PALETTE"

## format of a standard resdat (NARC-based, not file-based):
#### 4 bytes - type
#### array of elements, each element is 24 bytes:
#### 4 bytes for each: narc index, member index, compress flag, id number, vram type, palette count
#### palette count field is only used for PALETTE resdats, other resdats fill this with the narc index
#### vram type field is only used for PALETTE and TILES resdats, other resdats fill this with the narc index
#### terminated with 6 ints of -2
with open(output_file, mode="wb") as f:
    f.write(struct.pack('<i', type_idx))
    for element in data['contents']:
        f.write(struct.pack('<i', element['narc']))
        f.write(struct.pack('<i', element['member']))
        f.write(struct.pack('<i', 1 if element['compressed'] else 0))
        f.write(struct.pack('<i', element['id']))
        if type_idx == 0 or type_idx == 1:
            f.write(struct.pack('<i', element['vramType']))
        else:
            f.write(struct.pack('<i', element['narc']))
        if type_idx == 1:
            f.write(struct.pack('<i', element['paletteCount']))
        else:
            f.write(struct.pack('<i', element['narc']))
    for _ in range(6):
        f.write(struct.pack('<i', -2))

# if required, output a header. this can be consumed by C sources which need to know resdat offsets (e.g. for palette indices).
header_file = output_file.with_suffix(".h")
if output_header:
    fn = output_file.stem.upper()
    with open(header_file, mode="w") as f:
        f.write("// Header was automatically generated by make_resdat.py, please do not modify.\n")
        f.write(f"// This header provides offset into the resdat palette table for {output_file.stem} which can be used to access specific palette indices.\n\n")
        f.write(f"#ifndef RESDAT_{fn}_H_\n")
        f.write(f"#define RESDAT_{fn}_H_\n\n")
        f.write("enum {\n")
        running_offset = 0
        index = 0
        for element in data['contents']:
            element_name = f"RESDAT_{fn}_NARC_{element['narc']}_MEMBER_{element['member']}_{index}_OFFSET"
            # TODO: figure out a mapping from narc/member IDs to names here and plug the filename.
            f.write(f"\t{element_name} = {running_offset},\n")
            index += 1
            running_offset += element['paletteCount']
        f.write("};\n\n")
        f.write(f"/* RESDAT_{fn}_H_ */\n")
        f.write("#endif\n")